{"version":3,"sources":["../../src/datasource-zabbix/zabbixDBConnector.js"],"names":["ZabbixDBConnectorFactory","datasourceSrv","backendSrv","ZabbixDBConnector","sqlDataSourceId","options","limit","DEFAULT_QUERY_LIMIT","loadSQLDataSource","datasourceId","ds","_","find","getAll","loadDatasource","name","then","console","log","Promise","reject","items","timeFrom","timeTill","intervalMs","consolidateBy","intervalSec","Math","ceil","aggFunction","consolidateByFunc","grouped_items","groupBy","promises","map","value_type","itemids","join","table","HISTORY_TO_TABLE_MAP","query","invokeSQLQuery","all","flatten","results","history","addHostName","convertHistory","queryDef","refId","format","rawSql","maxDataPoints","datasourceRequest","url","method","data","queries","response","series","time_series","hosts","uniqBy","grafanaSeries","itemid","datapoints","points","item","alias","keys","length","host","hostid","target","sortBy","angular","module","factory"],"mappings":"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","file":"zabbixDBConnector.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\n\nconst DEFAULT_QUERY_LIMIT = 10000;\nconst HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nconst consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\n/** @ngInject */\nfunction ZabbixDBConnectorFactory(datasourceSrv, backendSrv) {\n\n  class ZabbixDBConnector {\n\n    constructor(sqlDataSourceId, options = {}) {\n      let {limit} = options;\n\n      this.sqlDataSourceId = sqlDataSourceId;\n      this.limit = limit || DEFAULT_QUERY_LIMIT;\n\n      // Try to load DS with given id to check it's exist\n      this.loadSQLDataSource(sqlDataSourceId);\n    }\n\n    loadSQLDataSource(datasourceId) {\n      let ds = _.find(datasourceSrv.getAll(), {'id': datasourceId});\n      if (ds) {\n        return datasourceSrv.loadDatasource(ds.name)\n        .then(ds => {\n          console.log('SQL data source loaded', ds);\n        });\n      } else {\n        return Promise.reject(`SQL Data Source with ID ${datasourceId} not found`);\n      }\n    }\n\n    getHistory(items, timeFrom, timeTill, options) {\n      let {intervalMs, consolidateBy} = options;\n      let intervalSec = Math.ceil(intervalMs / 1000);\n\n      consolidateBy = consolidateBy || 'avg';\n      let aggFunction = consolidateByFunc[consolidateBy];\n\n      // Group items by value type and perform request for each value type\n      let grouped_items = _.groupBy(items, 'value_type');\n      let promises = _.map(grouped_items, (items, value_type) => {\n        let itemids = _.map(items, 'itemid').join(', ');\n        let table = HISTORY_TO_TABLE_MAP[value_type];\n\n        let query = `\n          SELECT itemid AS metric, clock AS time_sec, ${aggFunction}(value) as value\n            FROM ${table}\n            WHERE itemid IN (${itemids})\n              AND clock > ${timeFrom} AND clock < ${timeTill}\n            GROUP BY time_sec DIV ${intervalSec}, metric\n        `;\n\n        return this.invokeSQLQuery(query);\n      });\n\n      return Promise.all(promises).then(results => {\n        return _.flatten(results);\n      });\n    }\n\n    handleHistory(history, items, addHostName = true) {\n      return convertHistory(history, items, addHostName);\n    }\n\n    invokeSQLQuery(query) {\n      let queryDef = {\n        refId: 'A',\n        format: 'time_series',\n        datasourceId: this.sqlDataSourceId,\n        rawSql: query,\n        maxDataPoints: this.limit\n      };\n\n      return backendSrv.datasourceRequest({\n        url: '/api/tsdb/query',\n        method: 'POST',\n        data: {\n          queries: [queryDef],\n        }\n      })\n      .then(response => {\n        let results = response.data.results;\n        if (results['A']) {\n          return results['A'].series;\n        } else {\n          return null;\n        }\n      });\n    }\n  }\n\n  return ZabbixDBConnector;\n}\n\nangular\n  .module('grafana.services')\n  .factory('ZabbixDBConnector', ZabbixDBConnectorFactory);\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction convertHistory(time_series, items, addHostName) {\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid'); //uniqBy is needed to deduplicate\n  let grafanaSeries = _.map(time_series, series => {\n    let itemid = series.name;\n    let datapoints = series.points;\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    if (_.keys(hosts).length > 1 && addHostName) { //only when actual multi hosts selected\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    return {\n      target: alias,\n      datapoints: datapoints\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n"]}